\documentclass[11pt,notitlepage,a4paper]{article}
%\usepackage[a4paper,hmargin=1.3in,vmargin=1.3in]{geometry}
\usepackage[
  bookmarks=true,       % show bookmarks bar?
  unicode=true,         % non-Latin characters in Acrobat’s bookmarks
  pdftoolbar=false,     % show Acrobat’s toolbar?
  pdfmenubar=false,     % show Acrobat’s menu?
  pdffitwindow=false,   % window fit to page when opened
  pdfstartview={FitH},  % fits the width of the page to the window
  pdftitle={BLAKE3},    % title
  pdfauthor={TODO},     % author
  pdfsubject={BLAKE3},  % subject of the document
  pdfnewwindow=true,    % links in new window
  colorlinks=true,      % false: boxed links; true: colored links
  linkcolor=darkgreen,  % color of internal links
  citecolor=darkblue,   % color of links to bibliography
  filecolor=magenta,    % color of file links
  urlcolor=darkred,     % color of external links
]{hyperref}
\usepackage{url}
%\usepackage{fullpage}
\usepackage{a4wide}
\usepackage{amsmath,amssymb,cite,dsfont}

\usepackage{verbatim,footmisc}
\usepackage{array}
\usepackage{euler}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\fontfamily{phv}\selectfont
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{datetime}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[english]{babel}

\usepackage{xspace}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{tikz}
\usepackage[T1]{fontenc} % improves underscore rendering
\usepackage[shortcuts]{extdash} % unbreakable dashes, e.g. SHA\=/2
\usepackage[outputdir=build]{minted} % syntax highlighting using Pygments
\usepackage[title]{appendix} % add "Appendix" to each appendix section title
\usetikzlibrary
{
  calc,
  positioning,
  shapes,
  shapes.geometric,
  arrows
}

\definecolor{darkred}{RGB}{170,0,0}
\definecolor{darkblue}{RGB}{0,0,170}
\definecolor{darkgreen}{RGB}{0,170,0}

\newdateformat{mydate}{\THEYEAR.\twodigit\THEMONTH.\twodigit\THEDAY}

\newcommand{\GG}{\mathsf{G}}
\newcommand{\IV}{\text{IV}}
\newcommand{\cpress}{\text{\textbf{compress}}}
\newcommand{\lto}{\leftarrow}
\newcommand{\BB}{\mathsf{B2}}

\title{BLAKE3}

\begin{document}

\fontfamily{phv}\selectfont

\pagestyle{plain}

%\maketitle
\begin{center}
{\huge BLAKE3: one function, fast everywhere}

\bigskip

\mydate\today 
%%\quad---\quad
% {\large \tt REQUEST FOR COMMENTS, NOT A FINAL VERSION}

\medskip

\url{https://blake3.io}

\medskip

AUTHORS
%Jack O'Connor (\texttt{@oconnor663}) \\
%Jean-Philippe Aumasson (\texttt{@veorq}) \\
%Samuel Neves (\texttt{@sevenps}) \\
%Zooko Wilcox-O'Hearn (\texttt{@zooko}) \\
%Christian Winnerlein (\texttt{@codesinchaos})
\end{center}


\medskip

\begin{center}
  \begin{minipage}{0.92\linewidth}

      \textbf{Abstract.} We present the cryptographic hash function BLAKE3, an
      improved version of BLAKE2 and of its predecessor, the SHA\=/3 finalist
      BLAKE. BLAKE3 supports high degrees of parallelism, using an internal
      tree structure that scales up to any number of SIMD lanes and CPU cores.
      On Intel Kaby Lake, peak single-threaded throughput is 3x that of
      BLAKE2b, 4x that of SHA\=/2, and 8x that of SHA\=/3, and it can scale
      further using multiple threads. At the same time, BLAKE3 is efficient on
      smaller architectures and microcontrollers. Throughput on ARM Cortex-M0
      is 30\% higher than BLAKE2s or SHA\=/256, and 3x that of BLAKE2b,
      SHA\=/512, or SHA\=/3. Unlike BLAKE2 and SHA\=/2, which have incompatible
      variants optimized for different platforms, BLAKE3 is a single hash
      function, designed to be consistently fast in software across a wide
      variety of platforms and use cases.

   \end{minipage}
\end{center}

\smallskip

\section{Introduction}\label{sec:intro}

Since its announcement in 2012, BLAKE2 has seen widespread adoption, in large
part because of its strong performance in software. BLAKE2b and BLAKE2s are
included in OpenSSL and in the Python and Go standard libraries. BLAKE2b is
also included as the \texttt{b2sum} utility in GNU Coreutils, as the
\texttt{generichash} API in Libsodium, and as underlying hash function for
Argon2, the winner of the Password Hashing Competition in 2015.

A drawback of BLAKE2 has been its large number of incompatible variants. The
original BLAKE2 paper described 64-bit BLAKE2b, 32-bit BLAKE2s, the parallel
variants BLAKE2bp and BLAKE2sp, and a framework for tree modes. The BLAKE2X
paper added extendable output modes. None of these are compatible with each
other, and choosing the right one for an application means understanding both
the tradeoffs between them and also the state of language and library support.
BLAKE2b, the most widely supported, is rarely the fastest on any particular
platform. BLAKE2bp and BLAKE2sp, with much higher peak throughput on x86, are
sparsely supported and almost never used.

BLAKE3 eliminates this drawback. It is a single hash function with no variants,
designed to support all the use cases of BLAKE2, as well as new use cases like
streaming verification. Furthermore, it improves on performance, in some cases
dramatically. On Intel Kaby Lake, peak throughput on a single core is triple
that of BLAKE2b, and BLAKE3 can scale further to any number of cores. On ARM
Cortex-M0, throughput is 30\% higher than BLAKE2s and again triple that of
BLAKE2b.

Internally, BLAKE3 divides its input into 2 KiB chunks and arranges those
chunks as the leaves of a binary tree. This tree structure means that there is
no limit to the parallelism that BLAKE3 can exploit, given enough input. The
direct benefit of that parallelism is very high throughput on platforms with
SIMD support, including all modern x86 processors. Another benefit of hashing
chunks in parallel is that the implementation can use SIMD vectors of any
width, regardless of the word size of the compression function. That leaves us
free to use a compression function that is efficient on smaller architectures,
without sacrificing performance on x86\=/64.

The BLAKE3 compression function is closely based on BLAKE2s. BLAKE3 has the
same 128-bit security level and 256-bit default output size. The round function
is identical, along with the IV constants and the message schedule. Thus, all
the cryptanalysis of BLAKE2 applies directly to BLAKE3. Based on that analysis
and with the benefit of hindsight, we believe that BLAKE2 is overly
conservative in its number of rounds, and BLAKE3 reduces the number of rounds
from 10 to 7. BLAKE3 also changes the setup and finalization steps of the
compression function to support the internal tree structure, more efficient
keying, and extendable output.

The biggest changes from BLAKE2 to BLAKE3 are:

\begin{itemize}
    \item BLAKE3 uses an \textbf{internal tree structure}.
    \item There are \textbf{no variants or flavors}.
    \item The compression function uses \textbf{fewer rounds}.
    \item In lieu of a parameter block, the BLAKE3 API supports \textbf{three
        domain-separated modes}: \texttt{hash(input)},
        \texttt{keyed\_hash(input, key)}, and \texttt{derive\_key(key,
        context)}. These modes differ only in the internal flag bits they set.
    \item The space formerly occupied by the parameter block is now used for
        the optional 256-bit key, so \textbf{keying is zero-cost}.
    \item BLAKE3 has built-in support for \textbf{extendable output}. Like
        BLAKE2X, but unlike SHA\=/3 or HKDF, extended output is fully
        parallelizable.
\end{itemize}

\section{Specification}\label{sec:specification}

\subsection{Tree Structure}\label{sec:tree}

BLAKE3 splits its input into chunks of up to 2048 bytes and arranges those
chunks as the leaves of a binary tree. Only the last chunk may be shorter, and
it is empty if and only if the entire input is empty. If there is only one
chunk, that chunk is the root node and only node of the tree. Otherwise, the
chunks are joined with parent nodes. The structure of the tree is determined by
two rules:
\begin{itemize}
    \item Each left subtree is a complete binary tree, with all its chunks at
        the same depth, and number of chunks that is a power of 2.
    \item Each left subtree contains a number of chunks greater than or equal
        to the number of chunks in its sibling right subtree.
\end{itemize}
For example, trees from 1 to 4 chunks have the structure shown in
Figure~\ref{fig:fourchunks}.

\begin{figure}[h]
\centering
\begin{tikzpicture}

\node[draw,rectangle] (chunk1) at (0, 0) {$c_0$};

%%

\node[draw,rectangle,right=1cm of chunk1] (chunk2) {$c_0$};
\node[draw,rectangle,right=0.5cm of chunk2] (chunk3) {$c_1$};
\node[draw,rectangle,above=1cm of chunk2] (parent1) at ($(chunk2)!0.5!(chunk3)$) {\phantom{$p_0$}};
\draw[-latex] (chunk2) -- (parent1);
\draw[-latex] (chunk3) -- (parent1);

%%

\node[draw,rectangle,right=1cm of chunk3] (chunk2) {$c_0$};
\node[draw,rectangle,right=0.5cm of chunk2] (chunk3) {$c_1$};
\node[draw,rectangle,above=1cm of chunk2] (parent1) at ($(chunk2)!0.5!(chunk3)$) {\phantom{$p_0$}};
\node[draw,rectangle,right=0.5cm of parent1] (chunk4) {$c_2$};
\node[draw,rectangle,above=1cm of chunk4] (parent2) at ($(parent1)!0.5!(chunk4)$) {\phantom{$p_0$}};
\draw[-latex] (chunk2) -- (parent1);
\draw[-latex] (chunk3) -- (parent1);
\draw[-latex] (parent1) -- (parent2);
\draw[-latex] (chunk4) -- (parent2);

%%

\node[draw,rectangle,below right=1cm of chunk4] (chunk2) {$c_0$};
\node[draw,rectangle,right=0.5cm of chunk2] (chunk3) {$c_1$};
\node[draw,rectangle,above=1cm of chunk2] (parent1) at ($(chunk2)!0.5!(chunk3)$) {\phantom{$p_0$}};
\node[draw,rectangle,right=0.5cm of chunk3] (chunk4) {$c_2$};
\node[draw,rectangle,right=0.5cm of chunk4] (chunk5) {$c_3$};
\node[draw,rectangle,above=1cm of chunk4] (parent2) at ($(chunk4)!0.5!(chunk5)$) {\phantom{$p_0$}};
\node[draw,rectangle,above=1cm of parent2] (parent3) at ($(parent1)!0.5!(parent2)$) {\phantom{$p_0$}};
\draw[-latex] (chunk2) -- (parent1);
\draw[-latex] (chunk3) -- (parent1);
\draw[-latex] (chunk4) -- (parent2);
\draw[-latex] (chunk5) -- (parent2);
\draw[-latex] (parent1) -- (parent3);
\draw[-latex] (parent2) -- (parent3);

\end{tikzpicture}
\caption{Example tree structures. Note that only subtrees along the right edge
    of the tree change as the number of chunks grows. All left subtrees are
    fixed.}\label{fig:fourchunks}
\end{figure}

The compression function is used to derive a 32-byte chaining value from each
chunk and parent node. The chaining value of the root node is the BLAKE3 hash
of the input.

\subsection{Compression Function}\label{sec:compression}

The compression function takes an 8-word intial chaining value and a 16-word
message block, and it returns a new chaining value. Words are 4 bytes.
Converting between bytes and words is done in little-endian order. The inputs
to the compression function are:

\begin{itemize}
    \item The initial chaining value, $h = h_{0} \ldots h_{7}$.
    \item The message block, $m = m_{0} \ldots m_{15}$.
    \item The number of input bytes in the block, $b$.
    \item A 64-bit offset, $t=t_{0},t_{1}$, with $t_{0}$ the lower order word
        and $t_{1}$ the higher order word.
    \item A set of domain separation bit flags, $d$.
\end{itemize}

The compression function initializes its 16-word internal state $v_{0} \ldots
v_{15}$ as follows. $\oplus$~denotes bitwise exclusive-or, and $\IV_{0} \ldots
\IV_{7}$ are constants given in appendix~\ref{sec:roundfn}.

\begin{equation*}
\begin{pmatrix}
v_{0} & v_{1} & v_{2} & v_{3} \\
v_{4} & v_{5} & v_{6} & v_{7} \\
v_{8} & v_{9} & v_{10} & v_{11} \\
v_{12} & v_{13} & v_{14} & v_{15} \\
\end{pmatrix}
\leftarrow
\begin{pmatrix}
h_{0} & h_{1} & h_{2} & h_{3} \\
h_{4} & h_{5} & h_{6} & h_{7} \\
\IV_{0} & \IV_{1} & \IV_{2} & \IV_{3} \\
t_{0} \oplus \IV_{4} & t_{1} \oplus \IV_{5} & b \oplus \IV_{6} & d \oplus \IV_{7}
\end{pmatrix}
\end{equation*}

The compression function applies the round function to the state and the
message block 7 times, each time with a different message schedule. The round
function and the message schedule for each round are the same as in BLAKE2s.
They are reproduced in appendix~\ref{sec:roundfn}.

After 7 rounds of compression, the new chaining value $h_{0}' \ldots h_{7}'$ is
defined as:

\begin{align*}
    h_{0}' \ & \leftarrow \ v_{0} \oplus  v_{8} \\
    h_{1}' \ & \leftarrow \ v_{1} \oplus  v_{9} \\
    h_{2}' \ & \leftarrow \ v_{2} \oplus  v_{10} \\
    h_{3}' \ & \leftarrow \ v_{3} \oplus  v_{11} \\
    h_{4}' \ & \leftarrow \ v_{4} \oplus  v_{12} \\
    h_{5}' \ & \leftarrow \ v_{5} \oplus  v_{13} \\
    h_{6}' \ & \leftarrow \ v_{6} \oplus  v_{14} \\
    h_{7}' \ & \leftarrow \ v_{7} \oplus  v_{15}
\end{align*}

The domain separation constants used to build $d$ are CHUNK\_START, CHUNK\_END,
PARENT, ROOT, KEYED\_HASH, and DERIVE\_KEY. Their values are 1, 2, 4, 8, 16,
and 32, respectively, and they are combined with bitwise exclusive-or. Their
usage is described below.

\subsection{Chunk Chaining Values}\label{sec:chunk}

Each chunk, up to 2048 bytes, is split into blocks of up to 64 bytes. The last
block of a each chunk is padded with zeros to be 64 bytes. The last block of a
chunk is empty if and only if the chunk is empty, which is the case if and only
if the entire input is empty. Each block is parsed in little-endian order into
message words $m_{0} \ldots m_{15}$ and input into the compression function. If
a key is used, the initial chaining value $h_{0} \ldots h_{7}$ for the first
block of each chunk is the key words $k_{0} \ldots k_{7}$, otherwise it is
$\IV_{0} \ldots \IV_{7}$. The initial chaining value for subsequent blocks in
each chunk is the output of the compression function for the previous block.
The offset $t$ for each block is the starting byte index of its chunk, 0 for
all blocks in the first chunk, 2048 for all blocks in the second chunk, and so
on. The block length $b$ is the number of input bytes in each block prior to
padding, 64 for all blocks except possibly the last block of the last chunk.
The value of $d$ is partly determined by the mode, described below. The first
block of each chunk combines the CHUNK\_START constant with $d$, and the last
block of each chunk combines the CHUNK\_END constant with $d$. If a chunk
contains only one block, that block combines both CHUNK\_START and CHUNK\_END
with $d$. If a chunk is the root of its tree, the last block of that chunk also
combines the ROOT constant with $d$. The output of the compression function for
the last block in a chunk is the chaining value of that chunk.

\subsection{Parent Node Chaining Values}\label{sec:chunk}

Each parent node has exactly two children, each either a chunk or another
parent node. The chaining value of each parent node is given by a single call
to the compression function. As with chunks above, if a key is used, the
initial chaining value $h_{0} \ldots h_{7}$ is the key words $k_{0} \ldots
k_{7}$, otherwise it is $\IV_{0} \ldots \IV_{7}$. The message words $m_{0}
\ldots m_{15}$ are the concatenated chaining values of its two children, first
the left then the right. The offset $t$ for parent nodes is always 0. The
number of bytes $b$ for parent nodes is always 64. The value of $d$ is partly
determined by the mode, described below, and parent nodes combine the PARENT
constant with $d$. If a parent node is the root of the tree, it also combines
the ROOT constant with $d$. The the output of the compression function is the
chaining value of the parent node.

\nocite{*}
\bibliographystyle{plainurl}
\bibliography{blake3}

\begin{appendices}

\section{Round Function}\label{sec:roundfn}

    The compression function transforms the internal state $v_{0} \ldots v_{15}$
    through a sequence of 7 rounds. The round function is the same as in
    BLAKE2s. A round does:

\begin{center}
\begin{tabular}{ l l l l }
    $\GG_{0}(v_{0}, v_{4}, v_{8}, v_{12})$ &
    $\GG_{1}(v_{1}, v_{5}, v_{9}, v_{13})$ &
    $\GG_{2}(v_{2}, v_{6}, v_{10}, v_{14})$ &
    $\GG_{3}(v_{3}, v_{7}, v_{11}, v_{15})$ \\
    $\GG_{4}(v_{0}, v_{5}, v_{10}, v_{15})$ &
    $\GG_{5}(v_{1}, v_{6}, v_{11}, v_{12})$ &
    $\GG_{6}(v_{2}, v_{7}, v_{8}, v_{13})$ &
    $\GG_{7}(v_{3}, v_{4}, v_{9}, v_{14})$
\end{tabular}
\end{center}

    That is, a round applies a G function to each of the columns in parallel,
    and then to each of the diagonals in parallel. $\GG_i(a, b, c, d)$ is
    defined as:

\begin{align*}
    a \ & \leftarrow \ a + b + m_{\sigma_r(2i)} \\
    d \ & \leftarrow \ (d \oplus a) \ggg 16 \\
    c \ & \leftarrow \ c + d \\
    b \ & \leftarrow \ (b \oplus c) \ggg 12 \\
    a \ & \leftarrow \ a + b + m_{\sigma_r(2i+1)} \\
    d \ & \leftarrow \ (d \oplus a) \ggg 8 \\
    c \ & \leftarrow \ c + d \\
    b \ & \leftarrow \ (b \oplus c) \ggg 7
\end{align*}

\section{Rust Reference Implementation}\label{sec:referenceimpl}

\inputminted{rust}{reference_impl.rs}

\end{appendices}

\end{document}
